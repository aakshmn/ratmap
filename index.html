<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RatMap v0.2</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <script>
    // Disable right-click
    document.addEventListener("contextmenu", function(e) {
      e.preventDefault();
    });
    
    // Initialize app - removed password protection
    window.onload = function () {
      // Initialize the visibility of plate sections based on checkboxes
      updatePlateVisibility();
      
      // Apply initial visualization
      applyMetadataVisualization();
    };
  </script>
  <style>
    :root {
      --primary: #4361ee;
      --primary-light: #4895ef;
      --secondary: #3f37c9;
      --light: #f8f9fa;
      --dark: #212529;
      --success: #4cc9a1;
      --warning: #ffc857;
      --danger: #e63946;
      --gray-100: #f8f9fa;
      --gray-200: #e9ecef;
      --gray-300: #dee2e6;
      --gray-400: #ced4da;
      --gray-500: #adb5bd;
      --gray-600: #6c757d;
      --gray-700: #495057;
      --gray-800: #343a40;
      --gray-900: #212529;
      --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
      --shadow: 0 2px 4px rgba(0,0,0,0.1);
      --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
      --border-radius: 6px;
      --transition: all 0.2s ease-in-out;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color: var(--dark);
      background-color: var(--light);
      line-height: 1.5;
      margin: 0;
      padding: 0;
    }

    .container {
      width: 100%;
      max-width: 100%;
      margin: 0 auto;
      padding: 0.75rem 0.75rem 0.25rem 0.75rem; /* Reduced bottom padding */
    }

    /* Header styling - simplified horizontal layout */
    .top-section {
      display: flex;
      margin-bottom: 0.4rem;
      align-items: flex-start;
    }

    .header-left {
      flex: 1;
      padding-right: 1rem;
      max-width: 60%;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .subheader {
      color: var(--gray-700);
      font-size: 0.9rem;
      line-height: 1.4;
      text-align: left;
      padding: 0;
      margin: 0;
    }

    .subheader strong {
      font-style: normal;
      font-weight: 600;
      color: var(--primary);
    }

    /* Save/Load buttons aligned with toggles */
    .save-load-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .save-load-buttons button {
      font-size: 0.8rem;
      white-space: nowrap;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    /* Plates selection in a single row */
    .plates-selection-section {
      display: flex;
    }

    .plates-selection-content {
      display: flex;
      gap: 0.5rem;
    }

    .plates-selection-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
    }

    a {
      color: var(--primary);
      text-decoration: none;
      transition: var(--transition);
    }

    a:hover {
      color: var(--primary-light);
      text-decoration: underline;
    }

    h3 {
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
      text-align: center;
      color: var(--secondary);
    }

    /* Card styles */
    .card {
      background-color: white;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      margin-bottom: 0.75rem;
      border: 1px solid var(--gray-200);
      overflow: hidden;
    }

    .card-body {
      padding: 0.75rem;
    }

    /* Controls section */
    .controls-section {
      margin-bottom: 0.75rem;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: minmax(180px, 1fr) minmax(90px, 0.5fr) minmax(200px, 1.2fr) minmax(90px, 0.5fr) minmax(90px, 0.5fr) minmax(90px, 0.5fr) minmax(70px, 0.4fr) minmax(180px, 1fr) minmax(180px, 1fr) minmax(90px, 0.5fr);
      gap: 0.4rem;
      align-items: center;
    }

    .control-item {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .control-item > * {
      min-width: 0;
      width: 100%;
    }

    .control-label {
      font-size: 0.75rem;
      color: var(--gray-600);
      white-space: nowrap;
      display: inline-block;
      margin-right: 0.25rem;
    }

    /* Form controls */
    select, input, button {
      padding: 0.4rem 0.6rem;
      border-radius: var(--border-radius);
      border: 1px solid var(--gray-300);
      font-size: 0.9rem;
      transition: var(--transition);
      background-color: white;
      width: 100%;
    }

    input:focus, select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
    }

    /* Make the assign, clear, and empty buttons more compact */
    #assignButton, #clearButton, #clearAllButton,
    #mapButton, #undoButton {
      padding: 0.3rem 0.5rem;
      white-space: nowrap;
    }

    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.4rem 0.6rem;
      border-radius: var(--border-radius);
      font-weight: 500;
      cursor: pointer;
      text-align: center;
      transition: var(--transition);
      border: 1px solid transparent;
      gap: 0.25rem;
      white-space: nowrap;
    }

    .btn-primary {
      background-color: var(--primary);
      color: white;
    }

    .btn-primary:hover {
      background-color: var(--primary-light);
    }

    .btn-outline {
      background-color: transparent;
      border: 1px solid var(--gray-300);
      color: var(--gray-700);
    }

    .btn-outline:hover {
      border-color: var(--primary);
      color: var(--primary);
    }

    .btn-success {
      background-color: var(--success);
      color: white;
    }

    .btn-success:hover {
      background-color: #36b089;
    }

    .btn-danger {
      background-color: var(--danger);
      color: white;
    }

    .btn-danger:hover {
      background-color: #d32f3a;
    }

    .btn-sm {
      font-size: 0.8rem;
      padding: 0.3rem 0.5rem;
    }

    /* Plate containers with enhanced scrolling */
    .plates-container {
      display: flex;
      flex-direction: column;
      width: 100%;
    }
    
    /* Media query for wide screens - show 96w and 384w side by side */
    @media (min-width: 1600px) {
      .plates-container {
        flex-direction: row;
        gap: 1rem;
      }
      
      .plate-section {
        flex: 1;
        max-width: 50%;
        width: 50%;
      }
    }
    
    /* Media query for different screen heights */
    @media (max-height: 768px) {
      .plate-section .card {
        height: calc(92vh - 50px); /* Slightly reduced height for smaller screens */
      }
    }
    
    /* Media query for very small screens */
    @media (max-height: 600px) {
      .plate-section .card {
        height: calc(88vh - 50px); /* Further reduced height for very small screens */
      }
    }
    
    /* Enhanced scrolling for plate sections */
    .plate-section .card {
      height: calc(95vh - 50px); /* Increased from 80vh to 95vh to fill more vertical space */
      display: flex;
      flex-direction: column;
    }
    
    /* Header is fixed, body scrolls */
    .plate-section .card-body {
      flex: 1;
      overflow: auto;
      padding: 0.75rem;
      scrollbar-width: thin; /* Firefox */
      -ms-overflow-style: -ms-autohiding-scrollbar; /* IE/Edge */
      max-height: none; /* Remove conflicting max-height */
    }
    
    /* Webkit scrollbar styling */
    .plate-section .card-body::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    .plate-section .card-body::-webkit-scrollbar-thumb {
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
    }
    
    .plate-section .card-body::-webkit-scrollbar-track {
      background-color: rgba(0, 0, 0, 0.05);
    }

    /* Plate sections with proper scrolling for panning */
    .plate-section {
      width: 100%;
      margin-bottom: 0.5rem; /* Reduced from 1rem to make cards closer to the bottom of the window */
      display: none; /* Hidden by default, shown based on checkbox selection */
    }

    .plate-section.active {
      display: block;
    }
    
    /* Plate wrapper and title */
    .plate-wrapper {
      margin-bottom: 1.5rem;
      width: 100%;
      min-width: 650px; /* Ensure tables have minimum width for scrolling */
    }
    
    .plate-wrapper h3 {
      font-size: 0.85rem;
      margin-bottom: 0.4rem;
      text-align: left;
      color: var(--secondary);
      padding-left: 0;
    }
    
    /* Two-column layout for 96-well plates */
    #plate96wContainer {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1rem;
      min-width: min-content;
    }
    
    /* Ensure one column on mobile */
    @media (max-width: 992px) {
      #plate96wContainer {
        grid-template-columns: 1fr;
      }
    }
    
    /* Card bodies containing plates should be scrollable for panning */
    .plate-section .card-body {
      padding: 0.75rem;
      overflow: auto;
      max-height: none; /* Remove conflicting max-height */
    }
    
    /* Plate table container - allow panning within parent */
    .plate-table-container {
      overflow: visible; /* Remove auto overflow to enable parent scrolling */
      margin-bottom: 0.5rem;
      border: 1px solid var(--gray-200);
      border-radius: var(--border-radius);
    }
    
    /* Table styling for panning */
    .plateTable {
      border-collapse: collapse;
      width: 100%;
      margin-bottom: 0.5rem;
      table-layout: fixed; /* For consistent cell sizing */
    }
    
    /* Set minimum dimensions for cells to ensure consistent sizes */
    .plateTable[data-plate$="96w"] th,
    .plateTable[data-plate$="96w"] td {
      min-width: 40px;
      min-height: 40px;
      width: 40px;
      height: 40px;
      max-width: 120px; /* Allow expansion but with max width */
    }
    
    .plateTable[data-plate$="384w"] th,
    .plateTable[data-plate$="384w"] td {
      min-width: 36px;
      min-height: 36px;
      width: 36px;
      height: 36px;
      max-width: 100px; /* Allow expansion but with max width */
    }
    
    /* Make all tables in the same container have the same width */
    #plate96wContainer .plateTable,
    #plate384wContainer .plateTable {
      width: 100%;
    }
    
    .plateTable th, .plateTable td {
      border: 1px solid var(--gray-400);
      text-align: center;
      font-size: 0.7rem;
      padding: 4px;
      word-wrap: break-word;
      overflow-wrap: break-word;
      word-break: break-word;
      height: 100%;
    }
    
    /* Adjust header styling - remove sticky positioning for panning */
    .plateTable th {
      background-color: var(--gray-100);
      font-weight: 600;
      cursor: pointer;
      user-select: none;
      transition: var(--transition);
      position: relative; /* Changed from sticky to enable panning */
      z-index: 2;
    }
    
    .plateTable th:first-child {
      position: relative; /* Changed from sticky to enable panning */
      z-index: 3;
    }
    
    .plateTable th:hover {
      background-color: var(--gray-200);
    }

    .plateTable td {
      background-color: white;
      cursor: pointer;
      user-select: none;
      transition: var(--transition);
    }

    .plateTable td:hover {
      background-color: rgba(67, 97, 238, 0.05);
    }

    .plateTable .selected {
      background-color: rgba(67, 97, 238, 0.2) !important;
      outline: 2px solid rgba(67, 97, 238, 0.8) !important;
      outline-offset: -2px;
    }

    /* Well content styling */
    .well-id {
      font-weight: bold;
      color: var(--gray-800);
      margin-bottom: 2px;
    }
    
    .metadata {
      color: var(--gray-700);
      font-size: 0.65rem;
      line-height: 1.3;
      white-space: normal;
      word-break: break-word;
      text-align: left;
    }

    /* Memory usage */
    #memoryUsage {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: var(--border-radius);
      background-color: var(--gray-100);
      font-size: 0.8rem;
      color: var(--gray-700);
    }

    /* Keyboard Shortcuts Help Popup */
    .shortcuts-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: white;
      border-radius: var(--border-radius);
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 1000;
      display: none;
      padding: 1.5rem;
    }
    
    .shortcuts-popup.active {
      display: block;
    }
    
    .shortcuts-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0,0,0,0.5);
      z-index: 999;
      display: none;
    }
    
    .shortcuts-overlay.active {
      display: block;
    }
    
    .shortcuts-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--gray-200);
    }
    
    .shortcuts-title {
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--primary);
      margin: 0;
    }
    
    .shortcuts-close {
      background: none;
      border: none;
      color: var(--gray-600);
      cursor: pointer;
      font-size: 1.2rem;
      padding: 0.25rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.2s;
    }
    
    .shortcuts-close:hover {
      color: var(--gray-800);
    }
    
    .shortcuts-section {
      margin-bottom: 1.5rem;
    }
    
    .shortcuts-section-title {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 0.75rem;
      color: var(--secondary);
    }
    
    .shortcuts-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .shortcuts-table tr:nth-child(odd) {
      background-color: var(--gray-50);
    }
    
    .shortcuts-table td {
      padding: 0.5rem 0.75rem;
      font-size: 0.9rem;
      border-bottom: 1px solid var(--gray-200);
    }
    
    .shortcuts-table td:first-child {
      font-weight: 500;
      white-space: nowrap;
    }
    
    .key {
      display: inline-block;
      background-color: var(--gray-200);
      border-radius: 4px;
      padding: 0.1rem 0.4rem;
      margin: 0 0.1rem;
      font-size: 0.85rem;
      font-family: monospace;
      box-shadow: 0 1px 1px rgba(0,0,0,0.1);
    }

    /* Export button - more compact */
    .export-btn {
      width: auto;
      min-width: 130px;
      font-size: 0.85rem;
    }

    /* Utility */
    .d-flex {
      display: flex;
    }

    .align-center {
      align-items: center;
    }

    .justify-between {
      justify-content: space-between;
    }

    .gap-1 {
      gap: 0.25rem;
    }

    .gap-2 {
      gap: 0.5rem;
    }

    .mb-1 {
      margin-bottom: 0.25rem;
    }

    .mb-2 {
      margin-bottom: 0.5rem;
    }

    .grow {
      flex-grow: 1;
    }

    .w-100 {
      width: 100%;
    }

    /* Responsive layout for the controls */
    @media (max-width: 1200px) {
      .controls-grid {
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        grid-template-rows: auto auto;
        grid-auto-flow: row;
      }
      
      .control-item.text-input {
        grid-column: 1 / -1;
      }
    }
    
    @media (max-width: 992px) {
      .plates-selection-group {
        flex-wrap: wrap;
      }
    }
    
    @media (max-width: 768px) {
      .controls-grid {
        grid-template-columns: 1fr;
      }
      
      .top-section {
        flex-direction: column;
      }
      
      .header-left {
        max-width: 100%;
        margin-bottom: 0.5rem;
      }
      
      .header-right {
        flex-direction: column;
        width: 100%;
        align-items: flex-start;
        gap: 0.5rem;
      }
      
      .plates-selection-section {
        width: 100%;
      }
      
      .plates-selection-content {
        flex-wrap: wrap;
      }
      
      .save-load-buttons {
        margin-bottom: 0.5rem;
      }
    }
    
    /* Prevent user-select during drag operations */
    .plateTable {
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    /* Mapping controls on a second row */
    .mapping-controls {
      display: grid;
      grid-template-columns: minmax(80px, 0.8fr) minmax(200px, 1.5fr) minmax(80px, 0.8fr) minmax(200px, 1.5fr) minmax(100px, 0.6fr) minmax(100px, 0.6fr) minmax(100px, 0.5fr);
      gap: 0.5rem;
      align-items: center;
      margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px solid var(--gray-200);
    }

    .mapping-label {
      font-size: 0.75rem;
      color: var(--gray-600);
      white-space: nowrap;
      margin-right: 0.1rem;
    }

    /* Plate header styling */
    .plate-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0.75rem;
      background-color: rgba(67, 97, 238, 0.05);
      border-bottom: 1px solid var(--gray-200);
    }

    .plate-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--secondary);
      margin: 0;
      flex: 1;
    }

    /* Make the buttons more compact */
    #saveDataButton, #loadDataButton, 
    #export96Button, #export384Button {
      padding: 0.3rem 0.6rem;
      white-space: nowrap;
    }

    /* Cell content styling */
    .well-content {
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      word-wrap: break-word;
      line-height: 1.2;
    }

    /* Plate checkbox styles */
    .plate-checkbox-label {
      display: inline-flex;
      align-items: center;
      padding: 0.15rem 0.3rem;
      border-radius: var(--border-radius);
      background-color: var(--gray-100);
      transition: var(--transition);
      cursor: pointer;
      font-size: 0.7rem;
      user-select: none;
      margin-bottom: 0;
    }

    .plate-checkbox-label:hover {
      background-color: var(--gray-200);
    }

    .plate-checkbox-label.active {
      background-color: rgba(67, 97, 238, 0.1);
      color: var(--primary);
      font-weight: 500;
    }

    .plate-checkbox-label input {
      margin-right: 0.2rem;
      width: auto;
      height: 0.8rem;
    }

    /* Equal width for source and destination dropdowns */
    #srcPlateSelect, #destQuadSelect {
      width: 100%;
      min-width: 180px;
    }

    /* Set minimum table dimensions to ensure scrollability */
    #plate96wContainer, #plate384wContainer {
      min-width: min-content;
    }
    
    /* Adjust table dimensions to ensure they remain visible during scrolling */
    .plateTable {
      margin: 0;
      border: 1px solid var(--gray-300);
    }
    
    /* Ensure scroll containers have proper dimensions */
    .plate-table-container {
      min-width: fit-content;
      margin: 0 0 1rem 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header section -->
    <div class="top-section">
      <div class="header-left">
        <div class="subheader">
          <strong>RatMap (v0.2).</strong> An opinionated plate mapping tool for filthy festering lab rats. 💩🐀 Created by <a href="https://github.com/aakshmn" target="_blank">aakshmn</a>. 
          (<a href="https://github.com/aakshmn/ratmap/blob/main/README.md" target="_blank">README</a>)
        </div>
      </div>
      
      <div class="header-right">
        <!-- Save/Load buttons first -->
        <div class="save-load-buttons">
          <button id="saveDataButton" class="btn btn-primary btn-sm">
            <i class="fa fa-save"></i> Save
          </button>
          <button id="loadDataButton" class="btn btn-outline btn-sm">
            <i class="fa fa-upload"></i> Load
          </button>
        </div>
        
        <!-- All toggles in a single row -->
        <div class="plates-selection-section">
          <div class="plates-selection-content">
            <div class="plates-selection-group">
              <label class="plate-checkbox-label" data-plate="P01_96w">
                <input type="checkbox" value="P01_96w" class="plate96wCheckbox"> P01_96w
              </label>
              <label class="plate-checkbox-label" data-plate="P02_96w">
                <input type="checkbox" value="P02_96w" class="plate96wCheckbox"> P02_96w
              </label>
              <label class="plate-checkbox-label" data-plate="P03_96w">
                <input type="checkbox" value="P03_96w" class="plate96wCheckbox"> P03_96w
              </label>
              <label class="plate-checkbox-label" data-plate="P04_96w">
                <input type="checkbox" value="P04_96w" class="plate96wCheckbox"> P04_96w
              </label>
              <label class="plate-checkbox-label" data-plate="P05_96w">
                <input type="checkbox" value="P05_96w" class="plate96wCheckbox"> P05_96w
              </label>
              <label class="plate-checkbox-label" data-plate="P06_96w">
                <input type="checkbox" value="P06_96w" class="plate96wCheckbox"> P06_96w
              </label>
              <label class="plate-checkbox-label" data-plate="P07_96w">
                <input type="checkbox" value="P07_96w" class="plate96wCheckbox"> P07_96w
              </label>
              <label class="plate-checkbox-label" data-plate="P08_96w">
                <input type="checkbox" value="P08_96w" class="plate96wCheckbox"> P08_96w
              </label>
              <label class="plate-checkbox-label" data-plate="P01_384w">
                <input type="checkbox" value="P01_384w" class="plate384wCheckbox"> P01_384w
              </label>
              <label class="plate-checkbox-label" data-plate="P02_384w">
                <input type="checkbox" value="P02_384w" class="plate384wCheckbox"> P02_384w
              </label>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Consolidated Controls Section -->
    <div class="card controls-section">
      <div class="card-body">
        <div class="controls-grid">
          <!-- Layer & Metadata Controls -->
          <div class="control-item">
            <select id="layerDropdown" title="Select metadata layer"></select>
          </div>
          <div class="control-item">
            <button id="renameLayerButton" class="btn btn-outline btn-sm">
              <i class="fa fa-pencil"></i> Rename
            </button>
          </div>
          <div class="control-item text-input">
            <input type="text" id="metadataValue" placeholder="Enter value">
          </div>
          <div class="control-item">
            <button id="assignButton" class="btn btn-primary btn-sm">
              <i class="fa fa-check"></i> Assign
            </button>
          </div>
          <div class="control-item">
            <button id="undoButton" class="btn btn-outline btn-sm">
              <i class="fa fa-undo"></i> Undo
            </button>
          </div>
          <div class="control-item">
            <button id="clearButton" class="btn btn-outline btn-sm">
              <i class="fa fa-eraser"></i> Clear
            </button>
          </div>
          <div class="control-item">
            <button id="clearAllButton" class="btn btn-danger btn-sm">
              <i class="fa fa-trash-alt"></i> Empty
            </button>
          </div>
          <!-- Mapping Controls -->
          <div class="control-item">
            <select id="srcPlateSelect"></select>
          </div>
          <div class="control-item">
            <select id="destQuadSelect"></select>
          </div>
          <div class="control-item">
            <button id="mapButton" class="btn btn-primary btn-sm">
              <i class="fa fa-exchange-alt"></i> Map
            </button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Plates Container -->
    <div class="plates-container">
      <!-- 96-well Plates Section - modified header -->
      <div class="plate-section" id="section96w">
        <div class="card">
          <div class="plate-header">
            <h2 class="plate-title">96-well Plates</h2>
            <button id="export96Button" class="btn btn-success btn-sm export-btn">
              <i class="fa fa-file-export"></i> Export CSV 🧀
            </button>
          </div>
          <div class="card-body">
            <div id="plate96wContainer"></div>
          </div>
        </div>
      </div>
      
      <!-- 384-well Plates Section - modified header -->
      <div class="plate-section" id="section384w">
        <div class="card">
          <div class="plate-header">
            <h2 class="plate-title">384-well Plates</h2>
            <button id="export384Button" class="btn btn-success btn-sm export-btn">
              <i class="fa fa-file-export"></i> Export CSV 🧀
            </button>
          </div>
          <div class="card-body">
            <div id="plate384wContainer"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Keyboard Shortcuts Popup -->
  <div class="shortcuts-overlay" id="shortcutsOverlay"></div>
  <div class="shortcuts-popup" id="shortcutsPopup">
    <div class="shortcuts-header">
      <h3 class="shortcuts-title">Keyboard Shortcuts</h3>
      <button class="shortcuts-close" id="shortcutsClose">
        <i class="fa fa-times"></i>
      </button>
    </div>
    
    <div class="shortcuts-section">
      <h4 class="shortcuts-section-title">General Controls</h4>
      <table class="shortcuts-table">
        <tr>
          <td><span class="key">Ctrl</span> + <span class="key">Shift</span> + <span class="key">L</span> or <span class="key">M</span></td>
          <td>Focus and select the metadata value input</td>
        </tr>
        <tr>
          <td><span class="key">Ctrl</span> + <span class="key">Shift</span> + <span class="key">S</span></td>
          <td>Focus the Source dropdown</td>
        </tr>
        <tr>
          <td><span class="key">Ctrl</span> + <span class="key">Shift</span> + <span class="key">D</span></td>
          <td>Focus the Destination dropdown</td>
        </tr>
        <tr>
          <td><span class="key">Ctrl</span> + <span class="key">Shift</span> + <span class="key">O</span></td>
          <td>Focus the 96-well plates Export button</td>
        </tr>
        <tr>
          <td><span class="key">Ctrl</span> + <span class="key">Shift</span> + <span class="key">P</span></td>
          <td>Focus the 384-well plates Export button</td>
        </tr>
        <tr>
          <td><span class="key">Ctrl</span> + <span class="key">S</span></td>
          <td>Save all data (Mac: <span class="key">⌘</span> + <span class="key">S</span>)</td>
        </tr>
        <tr>
          <td><span class="key">Ctrl</span> + <span class="key">O</span></td>
          <td>Load saved data (Mac: <span class="key">⌘</span> + <span class="key">O</span>)</td>
        </tr>
        <tr>
          <td><span class="key">Ctrl</span> + <span class="key">/</span></td>
          <td>Toggle this shortcuts help (Mac: <span class="key">⌘</span> + <span class="key">/</span>)</td>
        </tr>
        <tr>
          <td><span class="key">Esc</span></td>
          <td>Close shortcuts help popup</td>
        </tr>
      </table>
    </div>
    
    <div class="shortcuts-section">
      <h4 class="shortcuts-section-title">Plate Toggling</h4>
      <table class="shortcuts-table">
        <tr>
          <td><span class="key">Ctrl</span> + <span class="key">Alt</span> + <span class="key">1</span> - <span class="key">8</span></td>
          <td>Toggle 96-well plates P01 through P08 (Mac: <span class="key">⌘</span> + <span class="key">Option</span>)</td>
        </tr>
        <tr>
          <td><span class="key">Ctrl</span> + <span class="key">Alt</span> + <span class="key">9</span> - <span class="key">0</span></td>
          <td>Toggle 384-well plates P01 and P02 (Mac: <span class="key">⌘</span> + <span class="key">Option</span>)</td>
        </tr>
        <tr>
          <td><span class="key">Ctrl</span> + <span class="key">Alt</span> + <span class="key">Shift</span> + <span class="key">1</span> - <span class="key">0</span></td>
          <td>Select all wells in the corresponding plate (Mac: <span class="key">⌘</span> + <span class="key">Option</span> + <span class="key">Shift</span>)</td>
        </tr>
      </table>
    </div>
    
    <div class="shortcuts-section">
      <h4 class="shortcuts-section-title">Metadata Assignment</h4>
      <table class="shortcuts-table">
        <tr>
          <td><span class="key">Enter</span></td>
          <td>Assign value to selected well(s) in column-major order</td>
        </tr>
        <tr>
          <td><span class="key">Shift</span> + <span class="key">Enter</span></td>
          <td>Assign value to selected well(s) in row-major order</td>
        </tr>
        <tr>
          <td><span class="key">Shift</span> + <span class="key">Alt</span> + <span class="key">Enter</span></td>
          <td>Rename the current layer (Mac: <span class="key">Shift</span> + <span class="key">Option</span> + <span class="key">Enter</span>)</td>
        </tr>
      </table>
    </div>
  </div>
  
  <!-- Hidden file input for loading data -->
  <input type="file" id="fileInput" accept=".json" style="display:none;">
  
  <script>
    /***** Global Data & Layer Names *****/
    let plate96wData = {};
    let plate384wData = {};
    let lastState = null; // for one-level undo
    let currentVisualizationLayer = "metadata_1"; // Track which metadata layer we're visualizing

    // Global variable to control well advancement order.
    let advanceOrder = "column";

    // Maintain an array of layer names.
    let layerNames = ["Metadata_1", "Metadata_2", "Metadata_3", "Metadata_4", "Metadata_5", "Metadata_6", "Metadata_7", "Metadata_8", "Metadata_9"];

    // Define rows and columns.
    const rows96 = ['A','B','C','D','E','F','G','H'];
    const cols96 = Array.from({length: 12}, (_, i) => String(i+1).padStart(2, '0'));
    const rows384 = "ABCDEFGHIJKLMNOP".split('');
    const cols384 = Array.from({length: 24}, (_, i) => String(i+1).padStart(2, '0'));

    /***** Utility: Update Layer Dropdown *****/
    function updateLayerDropdowns() {
      const dropdown = document.getElementById("layerDropdown");
      dropdown.innerHTML = "";
      for (let i = 0; i < layerNames.length; i++) {
        let optionText = (i+1) + ". " + layerNames[i];
        let opt = document.createElement("option");
        opt.value = "metadata_" + (i+1);
        opt.textContent = optionText;
        dropdown.appendChild(opt);
      }
    }
    updateLayerDropdowns();
    
    // Add change event to layer dropdown to update visualization
    document.getElementById("layerDropdown").addEventListener("change", function() {
      applyMetadataVisualization();
    });

    /***** Undo Functions *****/
    function saveUndoState() {
      lastState = {
        plate96wData: JSON.parse(JSON.stringify(plate96wData)),
        plate384wData: JSON.parse(JSON.stringify(plate384wData))
      };
    }
    function undoLastAction() {
      if (!lastState) {
        alert("Nothing to undo.");
        return;
      }
      plate96wData = JSON.parse(JSON.stringify(lastState.plate96wData));
      plate384wData = JSON.parse(JSON.stringify(lastState.plate384wData));
      lastState = null;
      updateAllDisplayedCells();
      document.querySelectorAll("th.selected").forEach(el => el.classList.remove("selected"));
      updateRatCache();
      
      // Update visualization after undo
      applyMetadataVisualization();
    }

    /***** Initialization Functions for Plates *****/
    function initPlate96(plateId) {
      let data = {};
      rows96.forEach(r => {
        cols96.forEach(c => {
          let wellId = r + c;
          let wellData = {};
          for (let i = 1; i <= 9; i++) {
            wellData["metadata_" + i] = "";
          }
          data[wellId] = wellData;
        });
      });
      plate96wData[plateId] = data;
    }
    function initPlate384(plateId) {
      let data = {};
      rows384.forEach(r => {
        cols384.forEach(c => {
          let wellId = r + c;
          let wellData = {};
          for (let i = 1; i <= 9; i++) {
            wellData["metadata_" + i] = "";
          }
          wellData.Src_Plate_96w = "";
          wellData.Src_Well_96w = "";
          data[wellId] = wellData;
        });
      });
      plate384wData[plateId] = data;
    }

    /***** Plate Table Generation *****/
    function generate96PlateTable(plateId) {
      let table = document.createElement("table");
      table.className = "plateTable";
      table.setAttribute("data-plate", plateId);
      let thead = document.createElement("thead");
      let headerRow = document.createElement("tr");
      let topLeft = document.createElement("th");
      topLeft.className = "select-all";
      topLeft.textContent = "";
      headerRow.appendChild(topLeft);
      cols96.forEach(col => {
        let th = document.createElement("th");
        th.textContent = col;
        th.setAttribute("data-col", col);
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);
      let tbody = document.createElement("tbody");
      rows96.forEach(row => {
        let tr = document.createElement("tr");
        let th = document.createElement("th");
        th.textContent = row;
        th.setAttribute("data-row", row);
        tr.appendChild(th);
        cols96.forEach(col => {
          let td = document.createElement("td");
          let wellId = row + col;
          td.className = "well";
          td.setAttribute("data-well", wellId);
          td.setAttribute("data-plate", plateId);
          updateCellDisplay96(td, plateId, wellId);
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      return table;
    }
    function generate384PlateTable(plateId) {
      let table = document.createElement("table");
      table.className = "plateTable";
      table.setAttribute("data-plate", plateId);
      let thead = document.createElement("thead");
      let headerRow = document.createElement("tr");
      let topLeft = document.createElement("th");
      topLeft.className = "select-all";
      topLeft.textContent = "";
      headerRow.appendChild(topLeft);
      cols384.forEach(col => {
        let th = document.createElement("th");
        th.textContent = col;
        th.setAttribute("data-col", col);
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);
      let tbody = document.createElement("tbody");
      rows384.forEach(row => {
        let tr = document.createElement("tr");
        let th = document.createElement("th");
        th.textContent = row;
        th.setAttribute("data-row", row);
        tr.appendChild(th);
        cols384.forEach(col => {
          let td = document.createElement("td");
          let wellId = row + col;
          td.className = "well";
          td.setAttribute("data-well", wellId);
          td.setAttribute("data-plate", plateId);
          updateCellDisplay384(td, plateId, wellId);
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      return table;
    }

    /***** Display Update Functions *****/
    function updateCellDisplay96(cell, plateId, wellId) {
      let data = plate96wData[plateId][wellId];
      let html = `<div class="well-id">${wellId}</div><div class="well-content">`;
      for (let i = 1; i <= 9; i++) {
        let key = "metadata_" + i;
        if (data[key]) {
          html += `<div class="metadata">${i}: ${data[key]}</div>`;
        }
      }
      html += '</div>';
      cell.innerHTML = html;
    }
    function updateCellDisplay384(cell, plateId, wellId) {
      let data = plate384wData[plateId][wellId];
      let html = `<div class="well-id">${wellId}</div><div class="well-content">`;
      for (let i = 1; i <= 9; i++) {
        let key = "metadata_" + i;
        if (data[key]) {
          html += `<div class="metadata">${i}: ${data[key]}</div>`;
        }
      }
      if (data.Src_Plate_96w || data.Src_Well_96w) {
        html += `<div class="metadata">Map: ${data.Src_Plate_96w} ${data.Src_Well_96w}</div>`;
      }
      html += '</div>';
      cell.innerHTML = html;
    }
    function updateAllDisplayedCells() {
      document.querySelectorAll("td.well").forEach(cell => {
        let plateId = cell.getAttribute("data-plate");
        let wellId = cell.getAttribute("data-well");
        if (plateId.includes("96w")) {
          updateCellDisplay96(cell, plateId, wellId);
        } else {
          updateCellDisplay384(cell, plateId, wellId);
        }
      });
      
      // Equalize dimensions after updating cells
      setTimeout(equalizeTableDimensions, 100);
    }

    /***** Selection and Visualization Handlers *****/
    function clearHeaderSelections() {
      document.querySelectorAll("th.selected").forEach(el => el.classList.remove("selected"));
    }
    
    function clearAllSelections() {
      document.querySelectorAll("td.well.selected, th.selected").forEach(el => el.classList.remove("selected"));
    }
    
    // Generate a color from a gradient based on index and total
    function getGradientColor(index, total) {
      // Define gradient stops with pastel colors
      const colors = [
        [173, 216, 230],    // Pastel blue
        [221, 160, 221],    // Pastel purple
        [255, 182, 193],    // Pastel pink
        [255, 218, 185],    // Pastel peach
        [255, 255, 153],    // Pastel yellow
        [144, 238, 144]     // Pastel green
      ];
      
      // Calculate position in the gradient
      const position = (index / (total - 1 || 1)) * (colors.length - 1);
      
      // Find the two colors to interpolate between
      const lowerIndex = Math.floor(position);
      const upperIndex = Math.min(colors.length - 1, lowerIndex + 1);
      
      // Calculate interpolation factor
      const factor = position - lowerIndex;
      
      // Interpolate between the two colors
      const r = Math.round(colors[lowerIndex][0] + factor * (colors[upperIndex][0] - colors[lowerIndex][0]));
      const g = Math.round(colors[lowerIndex][1] + factor * (colors[upperIndex][1] - colors[lowerIndex][1]));
      const b = Math.round(colors[lowerIndex][2] + factor * (colors[upperIndex][2] - colors[lowerIndex][2]));
      
      return `rgb(${r}, ${g}, ${b})`;
    }
    
    // Apply metadata visualization overlay
    function applyMetadataVisualization() {
      // Get the current metadata layer
      const layer = document.getElementById("layerDropdown").value;
      currentVisualizationLayer = layer;
      
      // Collect all distinct non-empty values for this layer across visible plates
      const distinctValues = new Set();
      
      // First, collect all values
      // 96-well plates
      getVisiblePlate96Ids().forEach(plateId => {
        const plate = plate96wData[plateId];
        for (const wellId in plate) {
          const value = plate[wellId][layer];
          if (value && value.trim() !== "") {
            distinctValues.add(value);
          }
        }
      });
      
      // 384-well plates
      getVisiblePlate384Ids().forEach(plateId => {
        const plate = plate384wData[plateId];
        for (const wellId in plate) {
          const value = plate[wellId][layer];
          if (value && value.trim() !== "") {
            distinctValues.add(value);
          }
        }
      });
      
      // Sort values (numerical or alphabetical)
      const sortedValues = Array.from(distinctValues).sort((a, b) => {
        // Try to compare as numbers first
        const numA = parseFloat(a);
        const numB = parseFloat(b);
        if (!isNaN(numA) && !isNaN(numB)) {
          return numA - numB;
        }
        // Otherwise compare as strings
        return a.localeCompare(b);
      });
      
      // Create a mapping from values to colors
      const colorMap = {};
      sortedValues.forEach((value, index) => {
        colorMap[value] = getGradientColor(index, sortedValues.length);
      });
      
      // Apply colors to all visible wells
      // 96-well plates
      getVisiblePlate96Ids().forEach(plateId => {
        const plate = plate96wData[plateId];
        for (const wellId in plate) {
          const cell = document.querySelector(`td.well[data-plate="${plateId}"][data-well="${wellId}"]`);
          const value = plate[wellId][layer];
          if (cell && value && value.trim() !== "") {
            cell.style.backgroundColor = colorMap[value];
          } else if (cell) {
            cell.style.backgroundColor = "";
          }
        }
      });
      
      // 384-well plates
      getVisiblePlate384Ids().forEach(plateId => {
        const plate = plate384wData[plateId];
        for (const wellId in plate) {
          const cell = document.querySelector(`td.well[data-plate="${plateId}"][data-well="${wellId}"]`);
          const value = plate[wellId][layer];
          if (cell && value && value.trim() !== "") {
            cell.style.backgroundColor = colorMap[value];
          } else if (cell) {
            cell.style.backgroundColor = "";
          }
        }
      });
    }

    function addSelectionHandlers(table) {
      // Track mouse state for drag selection
      let isDragging = false;
      let startCell = null;
      let startWasSelected = false;
      let lastHoveredCell = null;
      
      // Add handler for well clicks
      table.querySelectorAll("td.well, th").forEach(cell => {
        cell.addEventListener("mousedown", function(event) {
          // Only check for right click
          if (event.button === 2) {
            event.preventDefault();
            event.stopPropagation();
            return false;
          }
        }, true); // Use capturing phase
      });
      
      // Helper function to get all cells in a rectangle between two cells
      function getCellsInRectangle(cell1, cell2) {
        let plateId = cell1.getAttribute("data-plate");
        let well1 = cell1.getAttribute("data-well");
        let well2 = cell2.getAttribute("data-well");
        
        let rows, cols;
        if (plateId.includes("96w")) { 
          rows = rows96; 
          cols = cols96; 
        } else { 
          rows = rows384; 
          cols = cols384; 
        }
        
        let match1 = well1.match(/^([A-Z]+)([0-9]+)$/);
        let match2 = well2.match(/^([A-Z]+)([0-9]+)$/);
        
        if (!match1 || !match2) return [];
        
        let startRow = match1[1], startCol = match1[2];
        let endRow = match2[1], endCol = match2[2];
        let startRowIndex = rows.indexOf(startRow);
        let endRowIndex = rows.indexOf(endRow);
        let startColIndex = cols.indexOf(startCol);
        let endColIndex = cols.indexOf(endCol);
        
        // Ensure start indices are <= end indices
        let minRowIndex = Math.min(startRowIndex, endRowIndex);
        let maxRowIndex = Math.max(startRowIndex, endRowIndex);
        let minColIndex = Math.min(startColIndex, endColIndex);
        let maxColIndex = Math.max(startColIndex, endColIndex);
        
        // Get all cells in the rectangle
        let cellsInRect = [];
        for (let r = minRowIndex; r <= maxRowIndex; r++) {
          for (let c = minColIndex; c <= maxColIndex; c++) {
            let rowLetter = rows[r];
            let colNumber = cols[c];
            let wellId = rowLetter + colNumber;
            let cell = table.querySelector(`td.well[data-plate="${plateId}"][data-well="${wellId}"]`);
            if (cell) {
              cellsInRect.push(cell);
            }
          }
        }
        
        return cellsInRect;
      }
      
      // Add mousedown, mousemove, and mouseup events to each well cell
      table.querySelectorAll("td.well").forEach(cell => {
        // Handle initial mouse down on a cell
        cell.addEventListener("mousedown", function(event) {
          // Prevent text selection during drag
          event.preventDefault();
          
          // If this is a right-click, don't start dragging
          if (event.button === 2) return;
          
          // Start dragging
          isDragging = true;
          startCell = cell;
          startWasSelected = cell.classList.contains("selected");
          
          // Toggle the first cell's selection state
          if (startWasSelected) {
            cell.classList.remove("selected");
          } else {
            cell.classList.add("selected");
          }
        });
        
        // Handle mouse movement over cells
        cell.addEventListener("mousemove", function(event) {
          // Only process if we're in the middle of a drag operation
          if (!isDragging || !startCell) return;
          
          // Prevent text selection during drag
          event.preventDefault();
          
          // If this is a different cell than the last one we processed
          if (cell !== lastHoveredCell) {
            lastHoveredCell = cell;
            
            // Get all cells in the rectangle and update their selection state
            const cellsInRect = getCellsInRectangle(startCell, cell);
            
            // Update all cells in the rectangle to match the starting cell's action (select or deselect)
            cellsInRect.forEach(rectCell => {
              if (startWasSelected) {
                rectCell.classList.remove("selected");
              } else {
                rectCell.classList.add("selected");
              }
            });
          }
        });
      });
      
      // Add mouseup event to document to handle drag end
      document.addEventListener("mouseup", function(event) {
        // Only process if we were dragging
        if (isDragging) {
          isDragging = false;
          startCell = null;
          lastHoveredCell = null;
        }
      });
      
      // Add mouseleave event to table to handle case where mouse leaves the table
      table.addEventListener("mouseleave", function(event) {
        // Only process if we were dragging
        if (isDragging) {
          isDragging = false;
          startCell = null;
          lastHoveredCell = null;
        }
      });
      
      // We don't need a separate click handler - the mousedown already handles toggling
      // The mouseup event will take care of resetting the drag state
      
      // Keep the existing header click handlers
      table.querySelectorAll("th[data-row]").forEach(th => {
        th.addEventListener("click", function() {
          let row = th.getAttribute("data-row");
          let cells = table.querySelectorAll(`td.well[data-well^="${row}"]`);
          let allSelected = true;
          cells.forEach(cell => { if (!cell.classList.contains("selected")) allSelected = false; });
          cells.forEach(cell => { allSelected ? cell.classList.remove("selected") : cell.classList.add("selected"); });
          th.classList.toggle("selected", !allSelected);
        });
      });
      
      table.querySelectorAll("th[data-col]").forEach(th => {
        th.addEventListener("click", function() {
          let col = th.getAttribute("data-col");
          let cells = table.querySelectorAll(`td.well[data-well$="${col}"]`);
          let allSelected = true;
          cells.forEach(cell => { if (!cell.classList.contains("selected")) allSelected = false; });
          cells.forEach(cell => { allSelected ? cell.classList.remove("selected") : cell.classList.add("selected"); });
          th.classList.toggle("selected", !allSelected);
        });
      });
      
      table.querySelector("th.select-all").addEventListener("click", function() {
        let cells = table.querySelectorAll("td.well");
        let allSelected = true;
        cells.forEach(cell => { if (!cell.classList.contains("selected")) allSelected = false; });
        cells.forEach(cell => { allSelected ? cell.classList.remove("selected") : cell.classList.add("selected"); });
        this.classList.toggle("selected", !allSelected);
      });
    }

    /***** Helper Functions for Well Advancement *****/
    function getNextWellId(plateId, currentWell) {
      let wellOrder = [];
      if (plateId.includes("96w")) {
        cols96.forEach(col => { rows96.forEach(row => { wellOrder.push(row + col); }); });
      } else if (plateId.includes("384w")) {
        cols384.forEach(col => { rows384.forEach(row => { wellOrder.push(row + col); }); });
      }
      let index = wellOrder.indexOf(currentWell);
      return (index !== -1 && index < wellOrder.length - 1) ? wellOrder[index + 1] : null;
    }
    function getNextWellIdRowMajor(plateId, currentWell) {
      let wellOrder = [];
      if (plateId.includes("96w")) {
        rows96.forEach(row => { cols96.forEach(col => { wellOrder.push(row + col); }); });
      } else if (plateId.includes("384w")) {
        rows384.forEach(row => { cols384.forEach(col => { wellOrder.push(row + col); }); });
      }
      let index = wellOrder.indexOf(currentWell);
      return (index !== -1 && index < wellOrder.length - 1) ? wellOrder[index + 1] : null;
    }
    function getPlateWellOrder(plateId, orderType) {
      let order = [];
      if (plateId.includes("96w")) {
        if (orderType === "row") { rows96.forEach(row => { cols96.forEach(col => { order.push(row + col); }); }); }
        else { cols96.forEach(col => { rows96.forEach(row => { order.push(row + col); }); }); }
      } else if (plateId.includes("384w")) {
        if (orderType === "row") { rows384.forEach(row => { cols384.forEach(col => { order.push(row + col); }); }); }
        else { cols384.forEach(col => { rows384.forEach(row => { order.push(row + col); }); }); }
      }
      return order;
    }

    /***** Utility Functions for CSV Export *****/
    function headerTextForKey(key) {
      let idx = parseInt(key.split("_")[1]) - 1;
      return layerNames[idx];
    }
    function getVisiblePlate96Ids() {
      let ids = [];
      document.querySelectorAll(".plate96wCheckbox:checked").forEach(cb => { ids.push(cb.value); });
      return ids;
    }
    function determineMetaColumns96() {
      let metaIncluded = {};
      for (let i = 1; i <= 9; i++) { metaIncluded["metadata_" + i] = false; }
      getVisiblePlate96Ids().forEach(plateId => {
        let plate = plate96wData[plateId];
        if (plate) {
          for (let well in plate) {
            for (let i = 1; i <= 9; i++){
              let key = "metadata_" + i;
              if (plate[well][key] && plate[well][key].trim() !== "") {
                metaIncluded[key] = true;
              }
            }
          }
        }
      });
      let included = [];
      for (let i = 1; i <= 9; i++){
        if (metaIncluded["metadata_" + i]) included.push("metadata_" + i);
      }
      return included;
    }
    function getVisiblePlate384Ids() {
      let ids = [];
      document.querySelectorAll(".plate384wCheckbox:checked").forEach(cb => { ids.push(cb.value); });
      return ids;
    }
    function determineMetaColumns384() {
      let metaIncluded = {};
      for (let i = 1; i <= 9; i++) { metaIncluded["metadata_" + i] = false; }
      getVisiblePlate384Ids().forEach(plateId => {
        let plate = plate384wData[plateId];
        if (plate) {
          for (let well in plate) {
            for (let i = 1; i <= 9; i++){
              let key = "metadata_" + i;
              if (plate[well][key] && plate[well][key].trim() !== "") {
                metaIncluded[key] = true;
              }
            }
          }
        }
      });
      let included = [];
      for (let i = 1; i <= 9; i++){
        if (metaIncluded["metadata_" + i]) included.push("metadata_" + i);
      }
      return included;
    }

    /***** The Memory Usage (formerly Rat Cache) *****/
    function updateRatCache() {
      let bytes = JSON.stringify({ plate96wData, plate384wData }).length;
      if (bytes > 200 * 1024 * 1024) {
        alert("Squeak alert! You're stuffing too much in the nest! Trim down or risk a crash, you data-gobbling vermin!");
      }
    }
    
    setInterval(updateRatCache, 5000);

    /***** Plate Selection & Visibility *****/
    function updatePlateVisibility() {
      const has96w = document.querySelectorAll('.plate96wCheckbox:checked').length > 0;
      const has384w = document.querySelectorAll('.plate384wCheckbox:checked').length > 0;
      
      // Update section visibility
      const section96w = document.getElementById('section96w');
      const section384w = document.getElementById('section384w');
      
      if (has96w) {
        section96w.classList.add('active');
        // Update checkbox labels
        document.querySelectorAll('.plate-checkbox-label[data-plate^="P"][data-plate$="96w"]').forEach(label => {
          if (label.querySelector('input').checked) {
            label.classList.add('active');
          } else {
            label.classList.remove('active');
          }
        });

        // Sort plates in numerical order
        sortPlatesByID('plate96wContainer');
      } else {
        section96w.classList.remove('active');
      }
      
      if (has384w) {
        section384w.classList.add('active');
        // Update checkbox labels
        document.querySelectorAll('.plate-checkbox-label[data-plate^="P"][data-plate$="384w"]').forEach(label => {
          if (label.querySelector('input').checked) {
            label.classList.add('active');
          } else {
            label.classList.remove('active');
          }
        });

        // Sort plates in numerical order
        sortPlatesByID('plate384wContainer');
      } else {
        section384w.classList.remove('active');
      }
      
      // Update mapping dropdowns
      updateMappingDropdowns();
      
      // Update visualization after plate visibility changes
      applyMetadataVisualization();
      
      // Equalize dimensions after a short delay to ensure DOM is updated
      setTimeout(equalizeTableDimensions, 100);
    }

    // Function to sort plates by their ID in the container
    function sortPlatesByID(containerId) {
      const container = document.getElementById(containerId);
      const plates = Array.from(container.children);
      
      if (plates.length <= 1) return; // No need to sort if there's only one plate or none
      
      // Sort plates by their ID
      plates.sort((a, b) => {
        const idA = a.id;
        const idB = b.id;
        
        // Extract the plate number (e.g., from P01_96w get 01)
        // This regex matches one or more digits after P
        const numA = idA.match(/P(\d+)_/)[1];
        const numB = idB.match(/P(\d+)_/)[1];
        
        // Convert to integers for correct numerical sorting (e.g., P10 comes after P09)
        return parseInt(numA, 10) - parseInt(numB, 10);
      });
      
      // Remove all plates from the container
      while (container.firstChild) {
        container.removeChild(container.firstChild);
      }
      
      // Add the plates back in sorted order
      plates.forEach(plate => {
        container.appendChild(plate);
      });
    }

    /***** Button Handlers *****/
    // Layer Rename (now uses the same dropdown & input)
    function performLayerRename() {
      let dropdown = document.getElementById("layerDropdown");
      let key = dropdown.value;
      let idx = parseInt(key.split("_")[1]) - 1;
      let newName = document.getElementById("metadataValue").value.trim();
      if (!newName) { alert("Please enter a new layer name."); return; }
      if (!/^[A-Za-z0-9_-]+$/.test(newName)) {
        alert("Invalid layer name. Only letters, numbers, underscores, and dashes are allowed.");
        return;
      }
      layerNames[idx] = newName;
      updateLayerDropdowns();
      dropdown.value = key; // Keep the renamed layer selected.
      document.getElementById("metadataValue").select();
    }
    document.getElementById("renameLayerButton").addEventListener("click", function() {
      performLayerRename();
    });
    
    // Assign Values (with updated whitespace/comma–separated support and auto–advance)
    document.getElementById("assignButton").addEventListener("click", function() {
      let selected = document.querySelectorAll("td.well.selected");
      if (selected.length === 0) {
        alert("No wells selected.");
        return;
      }
      let layer = document.getElementById("layerDropdown").value;
      let value = document.getElementById("metadataValue").value.trim();
      let parsedList = [];
      let advanceOrder = document.getElementById('advanceOrderCheckbox') && document.getElementById('advanceOrderCheckbox').checked ? "row" : "column";
      
      // Support for Shift key to toggle row-major ordering
      if (window.event && window.event.shiftKey) {
        advanceOrder = "row";
      }
      
      // Check if this is a comma or space-separated list
      if (value.includes(',') || value.includes(' ')) {
        // Handle quoted values with commas/spaces inside quotes
        let inQuote = false;
        let currentValue = '';
        for (let i = 0; i < value.length; i++) {
          let char = value[i];
          if (char === '"' && (i === 0 || value[i-1] !== '\\')) {
            inQuote = !inQuote;
            continue;
          }
          if ((char === ',' || char === ' ') && !inQuote) {
            if (currentValue.trim()) parsedList.push(currentValue.trim());
            currentValue = '';
            continue;
          }
          currentValue += char;
        }
        if (currentValue.trim()) parsedList.push(currentValue.trim());
      } else {
        parsedList = [value];
      }
      if (parsedList.length > 1) {
        if (parsedList.length !== selected.length) {
          alert("Error: Number of values in list (" + parsedList.length +
                ") does not match number of selected wells (" + selected.length + ").");
          return;
        }
        let plateId = selected[0].getAttribute("data-plate");
        for (let cell of selected) {
          if (cell.getAttribute("data-plate") !== plateId) {
            alert("Error: List assignment is only allowed on wells within a single plate.");
            return;
          }
        }
        let orderArray = getPlateWellOrder(plateId, advanceOrder);
        let selectedArray = Array.from(selected);
        selectedArray.sort((a, b) => {
          let wellA = a.getAttribute("data-well");
          let wellB = b.getAttribute("data-well");
          return orderArray.indexOf(wellA) - orderArray.indexOf(wellB);
        });
        saveUndoState();
        for (let i = 0; i < selectedArray.length; i++) {
          let cell = selectedArray[i];
          let wellId = cell.getAttribute("data-well");
          if (plateId.includes("96w")) {
            plate96wData[plateId][wellId][layer] = parsedList[i];
            updateCellDisplay96(cell, plateId, wellId);
          } else {
            plate384wData[plateId][wellId][layer] = parsedList[i];
            updateCellDisplay384(cell, plateId, wellId);
          }
        }
        if (selectedArray.length === 1) {
          let currentWell = selectedArray[0].getAttribute("data-well");
          let nextWell = (advanceOrder === "row") ? getNextWellIdRowMajor(plateId, currentWell) : getNextWellId(plateId, currentWell);
          selectedArray[0].classList.remove("selected");
          if (nextWell) {
            let nextCell = document.querySelector(`td.well[data-plate="${plateId}"][data-well="${nextWell}"]`);
            if (nextCell) nextCell.classList.add("selected");
          } else { clearAllSelections(); }
        } else { clearAllSelections(); }
        document.getElementById("metadataValue").select();
        advanceOrder = "column";
        updateRatCache();
        
        // Update visualization after metadata changes
        applyMetadataVisualization();
        
        // Equalize table dimensions after value assignment
        setTimeout(equalizeTableDimensions, 50);
        
        return;
      }
      let singleSelection = (selected.length === 1);
      let currentPlate, currentWell, nextWell;
      if (singleSelection) {
        let cell = selected[0];
        currentPlate = cell.getAttribute("data-plate");
        currentWell = cell.getAttribute("data-well");
        nextWell = (advanceOrder === "row") ? getNextWellIdRowMajor(currentPlate, currentWell) : getNextWellId(currentPlate, currentWell);
      }
      saveUndoState();
      selected.forEach(cell => {
        let plateId = cell.getAttribute("data-plate");
        let wellId = cell.getAttribute("data-well");
        if (plateId.includes("96w")) {
          plate96wData[plateId][wellId][layer] = value;
          updateCellDisplay96(cell, plateId, wellId);
        } else {
          plate384wData[plateId][wellId][layer] = value;
          updateCellDisplay384(cell, plateId, wellId);
        }
      });
      if (singleSelection) {
        document.querySelectorAll("th.selected").forEach(el => el.classList.remove("selected"));
        selected[0].classList.remove("selected");
        if (nextWell) {
          let nextCell = document.querySelector(`td.well[data-plate="${currentPlate}"][data-well="${nextWell}"]`);
          if (nextCell) nextCell.classList.add("selected");
        } else { clearAllSelections(); }
      } else { clearAllSelections(); }
      document.getElementById("metadataValue").select();
      advanceOrder = "column";
      updateRatCache();
      
      // Update visualization after metadata changes
      applyMetadataVisualization();
      
      // Equalize table dimensions after value assignment
      setTimeout(equalizeTableDimensions, 50);
    });
    
    // Clear button: Clear only the metadata value for the currently selected layer for selected wells.
    document.getElementById("clearButton").addEventListener("click", function() {
      let selected = document.querySelectorAll("td.well.selected");
      if (selected.length === 0) {
        alert("No wells selected.");
        return;
      }
      saveUndoState();
      let layer = document.getElementById("layerDropdown").value;
      selected.forEach(cell => {
        let plateId = cell.getAttribute("data-plate");
        let wellId = cell.getAttribute("data-well");
        if (plateId.includes("96w")) {
          plate96wData[plateId][wellId][layer] = "";
          updateCellDisplay96(cell, plateId, wellId);
        } else {
          plate384wData[plateId][wellId][layer] = "";
          updateCellDisplay384(cell, plateId, wellId);
        }
      });
      clearAllSelections();
      updateRatCache();
      
      // Update visualization after metadata changes
      applyMetadataVisualization();
      
      // Equalize table dimensions after clearing values
      setTimeout(equalizeTableDimensions, 50);
    });
    
    // Empty 🤮 button: Clear all metadata values across all metadata layers for selected wells.
    document.getElementById("clearAllButton").addEventListener("click", function() {
      let selected = document.querySelectorAll("td.well.selected");
      if (selected.length === 0) {
        alert("No wells selected.");
        return;
      }
      if (confirm("Hey you stinky little cheese hoarder. This will clear all metadata from the selected wells. Useful when things are getting rancid. 🤢 Click \"OK\" to proceed.")) {
        saveUndoState();
        selected.forEach(cell => {
          let plateId = cell.getAttribute("data-plate");
          let wellId = cell.getAttribute("data-well");
          if (plateId.includes("96w")) {
            let data = plate96wData[plateId][wellId];
            for (let i = 1; i <= 9; i++) {
              data["metadata_" + i] = "";
            }
            updateCellDisplay96(cell, plateId, wellId);
          } else {
            let data = plate384wData[plateId][wellId];
            for (let i = 1; i <= 9; i++) {
              data["metadata_" + i] = "";
            }
            updateCellDisplay384(cell, plateId, wellId);
          }
        });
        clearAllSelections();
        updateRatCache();
        
        // Update visualization after metadata changes
        applyMetadataVisualization();
        
        // Equalize table dimensions after clearing values
        setTimeout(equalizeTableDimensions, 50);
      }
    });
    
    // Export for 96-well Plates with modified experiment ID handling
    document.getElementById("export96Button").addEventListener("click", function() {
      let experimentId = prompt("Aged cheese needn't mold. Keep it tidy, with an Experiment ID. (Leave blank to skip)");
      let useExperimentId = false;
      
      if (experimentId !== null) {  // User didn't cancel
        if (experimentId && !/^[A-Za-z0-9_-]+$/.test(experimentId)) {
          alert("Invalid Experiment ID. Please enter a valid string of letters, numbers, dashes, or underscores (no spaces).");
          return;
        }
        useExperimentId = experimentId !== ""; // Set to true only if non-empty
      } else {
        return; // User clicked cancel, abort export
      }
      
      let metaCols = determineMetaColumns96();
      let headerMeta = metaCols.map(key => headerTextForKey(key));
      let header = ["sample_id_96w", "Plate_96w", "Well_96w"].concat(headerMeta);
      let csvContent = header.map(h => `"${h}"`).join(",") + "\n";
      
      document.querySelectorAll(".plate96wCheckbox:checked").forEach(cb => {
        let plateId = cb.value;
        let newPlateId = useExperimentId ? experimentId + "_" + plateId : plateId;
        let data = plate96wData[plateId];
        
        cols96.forEach(col => {
          rows96.forEach(row => {
            let wellId = row + col;
            let d = data[wellId];
            let sampleId = newPlateId + "_" + wellId;
            let rowArray = [sampleId, newPlateId, wellId];
            metaCols.forEach(key => { rowArray.push(d[key]); });
            csvContent += rowArray.map(item => `"${item}"`).join(",") + "\n";
          });
        });
      });
      
      let blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      let url = URL.createObjectURL(blob);
      let link = document.createElement("a");
      link.setAttribute("href", url);
      let filename = useExperimentId ? experimentId + "_plate96w_metadata.csv" : "plate96w_metadata.csv";
      link.setAttribute("download", filename);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });

    // Export for 384-well Plates with modified experiment ID handling
    document.getElementById("export384Button").addEventListener("click", function() {
      let experimentId = prompt("Aged cheese needn't mold. Keep it tidy, with an Experiment ID. (Leave blank to skip)");
      let useExperimentId = false;
      
      if (experimentId !== null) {  // User didn't cancel
        if (experimentId && !/^[A-Za-z0-9_-]+$/.test(experimentId)) {
          alert("Invalid Experiment ID. Please enter a valid string of letters, numbers, dashes, or underscores (no spaces).");
          return;
        }
        useExperimentId = experimentId !== ""; // Set to true only if non-empty
      } else {
        return; // User clicked cancel, abort export
      }
      
      let metaCols = determineMetaColumns384();
      let mappingUsed = false;
      
      document.querySelectorAll(".plate384wCheckbox:checked").forEach(cb => {
        let plateId = cb.value;
        let data = plate384wData[plateId];
        for (let well in data) {
          let d = data[well];
          if ((d.Src_Plate_96w && d.Src_Plate_96w.trim() !== "") || (d.Src_Well_96w && d.Src_Well_96w.trim() !== "")) {
            mappingUsed = true;
            break;
          }
        }
      });
      
      let headerMeta = metaCols.map(key => headerTextForKey(key));
      let header;
      
      if (mappingUsed) {
        header = ["sample_id_384w", "Plate_384w", "Well_384w", "Plate_384w_Quad", "sample_id_96w", "Src_Plate_96w", "Src_Well_96w"].concat(headerMeta);
      } else {
        header = ["sample_id_384w", "Plate_384w", "Well_384w", "Plate_384w_Quad"].concat(headerMeta);
      }
      
      let csvContent = header.map(h => `"${h}"`).join(",") + "\n";
      
      document.querySelectorAll(".plate384wCheckbox:checked").forEach(cb => {
        let plateId = cb.value;
        let newPlateId = useExperimentId ? experimentId + "_" + plateId : plateId;
        let data = plate384wData[plateId];
        
        cols384.forEach((col, colIndex) => {
          rows384.forEach((row, rowIndex) => {
            let wellId = row + col;
            let rnum = rowIndex + 1, cnum = colIndex + 1;
            let quadrant;
            
            if (rnum % 2 === 1 && cnum % 2 === 1) quadrant = "Q1";
            else if (rnum % 2 === 0 && cnum % 2 === 1) quadrant = "Q2";
            else if (rnum % 2 === 1 && cnum % 2 === 0) quadrant = "Q3";
            else quadrant = "Q4";
            
            let fullQuad = newPlateId + "_" + quadrant;
            let d = data[wellId];
            let sampleId384w = newPlateId + "_" + wellId;
            let rowArray = [sampleId384w, newPlateId, wellId, fullQuad];
            
            if (mappingUsed) {
              let sampleId96w = "";
              let newSrcPlate = "";
              
              if (d.Src_Plate_96w && d.Src_Well_96w) {
                newSrcPlate = useExperimentId ? experimentId + "_" + d.Src_Plate_96w : d.Src_Plate_96w;
                sampleId96w = newSrcPlate + "_" + d.Src_Well_96w;
              }
              
              rowArray.push(sampleId96w, newSrcPlate, d.Src_Well_96w);
            }
            
            metaCols.forEach(key => { rowArray.push(d[key]); });
            csvContent += rowArray.map(item => `"${item}"`).join(",") + "\n";
          });
        });
      });
      
      let blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      let url = URL.createObjectURL(blob);
      let link = document.createElement("a");
      link.setAttribute("href", url);
      let filename = useExperimentId ? experimentId + "_plate384w_metadata.csv" : "plate384w_metadata.csv";
      link.setAttribute("download", filename);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });
    
    // Mapping to Quadrant (Map Wells)
    document.getElementById("mapButton").addEventListener("click", function() {
      clearAllSelections();
      let srcPlate = document.getElementById("srcPlateSelect").value;
      let destQuadrant = document.getElementById("destQuadSelect").value;
      if (!srcPlate || !destQuadrant) {
        alert("Please select both a source 96-well plate and a destination quadrant.");
        return;
      }
      saveUndoState();
      let parts = destQuadrant.split("_Q");
      let destPlate = parts[0];
      let quadNum = parts[1];
      let srcWells = [];
      cols96.forEach(col => { rows96.forEach(row => { srcWells.push(row + col); }); });
      let destWells = [];
      cols384.forEach(col => { 
        rows384.forEach(row => {
          let rowIndex = rows384.indexOf(row) + 1;
          let colIndex = cols384.indexOf(col) + 1;
          let rowOk = (quadNum === "1" || quadNum === "3") ? (rowIndex % 2 === 1) : (rowIndex % 2 === 0);
          let colOk = (quadNum === "1" || quadNum === "2") ? (colIndex % 2 === 1) : (colIndex % 2 === 0);
          if (rowOk && colOk) destWells.push(row + col);
        });
      });
      destWells.sort((a, b) => {
        let aRow = a.charAt(0), bRow = b.charAt(0);
        let aCol = a.slice(1), bCol = b.slice(1);
        if (aCol === bCol) return rows384.indexOf(aRow) - rows384.indexOf(bRow);
        return parseInt(aCol) - parseInt(bCol);
      });
      if (srcWells.length !== 96 || destWells.length !== 96) {
        alert("Unexpected error: number of wells mismatch.");
        return;
      }
      let srcData = plate96wData[srcPlate];
      let destData = plate384wData[destPlate];
      for (let i = 0; i < 96; i++) {
        let srcWell = srcWells[i];
        let destWell = destWells[i];
        destData[destWell] = {};
        for (let j = 1; j <= 9; j++) { destData[destWell]["metadata_" + j] = ""; }
        destData[destWell].Src_Plate_96w = "";
        destData[destWell].Src_Well_96w = "";
        for (let j = 1; j <= 9; j++) {
          let key = "metadata_" + j;
          if (srcData[srcWell][key]) { destData[destWell][key] = srcData[srcWell][key]; }
        }
        destData[destWell].Src_Plate_96w = srcPlate;
        destData[destWell].Src_Well_96w = srcWell;
        let srcCell = document.querySelector(`td.well[data-plate="${srcPlate}"][data-well="${srcWell}"]`);
        if (srcCell) srcCell.classList.add("selected");
        let destCell = document.querySelector(`td.well[data-plate="${destPlate}"][data-well="${destWell}"]`);
        if (destCell) {
          updateCellDisplay384(destCell, destPlate, destWell);
          destCell.classList.add("selected");
        }
      }
      document.querySelectorAll("th.selected").forEach(el => el.classList.remove("selected"));
      updateRatCache();
      
      // Update visualization after mapping
      applyMetadataVisualization();
      
      // Equalize table dimensions after mapping operation
      setTimeout(equalizeTableDimensions, 50);
    });
    
    /***** Checkbox Handlers for Showing/Hiding Plates *****/
    document.querySelectorAll(".plate96wCheckbox").forEach(cb => {
      cb.addEventListener("change", function() {
        let plateId = cb.value;
        let container = document.getElementById("plate96wContainer");
        
        // Update checkbox label class
        const label = document.querySelector(`.plate-checkbox-label[data-plate="${plateId}"]`);
        if (this.checked) {
          label.classList.add('active');
        } else {
          label.classList.remove('active');
        }
        
        if (cb.checked) {
          if (!plate96wData[plateId]) initPlate96(plateId);
          let table = generate96PlateTable(plateId);
          addSelectionHandlers(table);
          let plateDiv = document.createElement("div");
          plateDiv.className = "plateWrapper";
          plateDiv.id = plateId;
          let label = document.createElement("h3");
          label.textContent = plateId;
          plateDiv.appendChild(label);
          let tableContainer = document.createElement("div");
          tableContainer.className = "plate-table-container";
          tableContainer.appendChild(table);
          plateDiv.appendChild(tableContainer);
          container.appendChild(plateDiv);
          
          // Sort plates immediately after adding a new one
          sortPlatesByID('plate96wContainer');
        } else {
          let plateDiv = document.getElementById(plateId);
          if (plateDiv) plateDiv.remove();
        }
        updatePlateVisibility();
      });
    });
    document.querySelectorAll(".plate384wCheckbox").forEach(cb => {
      cb.addEventListener("change", function() {
        let plateId = cb.value;
        let container = document.getElementById("plate384wContainer");
        
        // Update checkbox label class
        const label = document.querySelector(`.plate-checkbox-label[data-plate="${plateId}"]`);
        if (this.checked) {
          label.classList.add('active');
        } else {
          label.classList.remove('active');
        }
        
        if (cb.checked) {
          if (!plate384wData[plateId]) initPlate384(plateId);
          let table = generate384PlateTable(plateId);
          addSelectionHandlers(table);
          let plateDiv = document.createElement("div");
          plateDiv.className = "plateWrapper";
          plateDiv.id = plateId;
          let label = document.createElement("h3");
          label.textContent = plateId;
          plateDiv.appendChild(label);
          let tableContainer = document.createElement("div");
          tableContainer.className = "plate-table-container";
          tableContainer.appendChild(table);
          plateDiv.appendChild(tableContainer);
          container.appendChild(plateDiv);
          
          // Sort plates immediately after adding a new one
          sortPlatesByID('plate384wContainer');
        } else {
          let plateDiv = document.getElementById(plateId);
          if (plateDiv) plateDiv.remove();
        }
        updatePlateVisibility();
      });
    });
    function updateMappingDropdowns() {
      let srcSelect = document.getElementById("srcPlateSelect");
      srcSelect.innerHTML = "";
      document.querySelectorAll(".plate96wCheckbox:checked").forEach(cb => {
        let opt = document.createElement("option");
        opt.value = cb.value;
        opt.textContent = cb.value;
        srcSelect.appendChild(opt);
      });
      let destSelect = document.getElementById("destQuadSelect");
      destSelect.innerHTML = "";
      document.querySelectorAll(".plate384wCheckbox:checked").forEach(cb => {
        let plateId = cb.value;
        for (let q = 1; q <= 4; q++) {
          let opt = document.createElement("option");
          opt.value = plateId + "_Q" + q;
          opt.textContent = plateId + "_Q" + q;
          destSelect.appendChild(opt);
        }
      });
    }
    
    /***** Enter-Key Handler for Metadata Value Input *****/
    document.getElementById("metadataValue").addEventListener("keydown", function(event) {
      if (event.key === "Enter") {
        event.preventDefault();
        if (event.shiftKey && event.altKey) {
          // Shift+Alt+Enter (or Shift+Option+Enter on Mac) performs layer rename.
          performLayerRename();
        } else {
          advanceOrder = event.shiftKey ? "row" : "column";
          document.getElementById("assignButton").click();
        }
      }
    });
    
    /***** Undo Button Handler *****/
    document.getElementById("undoButton").addEventListener("click", function() {
      undoLastAction();
    });

    /***** Keyboard Shortcuts *****/
    document.addEventListener("keydown", function(e) {
      const isMac = /Mac|iPod|iPhone|iPad/.test(navigator.platform);
      
      // Toggle shortcuts help popup with Ctrl/Cmd + /
      if ((isMac ? e.metaKey : e.ctrlKey) && e.key === '/') {
        e.preventDefault();
        toggleShortcutsPopup();
        return;
      }
      
      // Save data with Ctrl/Cmd + S
      if ((isMac ? e.metaKey : e.ctrlKey) && e.key === 's' && !e.shiftKey) {
        e.preventDefault();
        saveAllData();
        return;
      }
      
      // Load data with Ctrl/Cmd + O
      if ((isMac ? e.metaKey : e.ctrlKey) && e.key === 'o' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('fileInput').click();
        return;
      }
      
      // Close shortcuts popup with Escape
      if (e.key === 'Escape' && document.getElementById('shortcutsPopup').classList.contains('active')) {
        e.preventDefault();
        closeShortcutsPopup();
        return;
      }
      
      // Plate toggling: Ctrl/Cmd + Alt [+ Shift] + [Digit]
      if ((isMac ? e.metaKey : e.ctrlKey) && e.altKey) {
        const plateMapping = {
          "Digit1": "P01_96w",
          "Digit2": "P02_96w",
          "Digit3": "P03_96w",
          "Digit4": "P04_96w",
          "Digit5": "P05_96w",
          "Digit6": "P06_96w",
          "Digit7": "P07_96w",
          "Digit8": "P08_96w",
          "Digit9": "P01_384w",
          "Digit0": "P02_384w"
        };
        if (e.code in plateMapping) {
          let plateId = plateMapping[e.code];
          if (e.shiftKey) {
            // Simulate click on plate's select-all header.
            let table = document.querySelector('table.plateTable[data-plate="'+plateId+'"]');
            if (table) {
              let thSelectAll = table.querySelector('th.select-all');
              if (thSelectAll) { thSelectAll.click(); }
            }
          } else {
            // Toggle the plate checkbox.
            let checkbox;
            if (plateId.includes("96w")) {
              checkbox = document.querySelector('input.plate96wCheckbox[value="'+plateId+'"]');
            } else {
              checkbox = document.querySelector('input.plate384wCheckbox[value="'+plateId+'"]');
            }
            if (checkbox) {
              checkbox.checked = !checkbox.checked;
              checkbox.dispatchEvent(new Event('change', { bubbles: true }));
            }
          }
          e.preventDefault();
          return;
        }
      }
      
      // Other shortcuts: Ctrl/Cmd + Shift (without Alt)
      if ((isMac ? e.metaKey : e.ctrlKey) && e.shiftKey && !e.altKey) {
        let key = e.key.toLowerCase();
        if (key === 'l' || key === 'm') {
          e.preventDefault();
          let input = document.getElementById("metadataValue");
          input.focus();
          input.select();
        } else if (key === 's') {
          e.preventDefault();
          let srcSelect = document.getElementById("srcPlateSelect");
          srcSelect.focus();
        } else if (key === 'd') {
          e.preventDefault();
          let destSelect = document.getElementById("destQuadSelect");
          destSelect.focus();
        } else if (key === 'o') {
          e.preventDefault();
          let export96 = document.getElementById("export96Button");
          export96.focus();
        } else if (key === 'p') {
          e.preventDefault();
          let export384 = document.getElementById("export384Button");
          export384.focus();
        }
      }
    });
    
    /***** Shortcuts Popup Functions *****/
    function toggleShortcutsPopup() {
      const popup = document.getElementById('shortcutsPopup');
      const overlay = document.getElementById('shortcutsOverlay');
      
      if (popup.classList.contains('active')) {
        closeShortcutsPopup();
      } else {
        popup.classList.add('active');
        overlay.classList.add('active');
      }
    }
    
    function closeShortcutsPopup() {
      const popup = document.getElementById('shortcutsPopup');
      const overlay = document.getElementById('shortcutsOverlay');
      
      popup.classList.remove('active');
      overlay.classList.remove('active');
    }
    
    // Event listeners for shortcuts popup
    document.getElementById('shortcutsClose').addEventListener('click', closeShortcutsPopup);
    document.getElementById('shortcutsOverlay').addEventListener('click', closeShortcutsPopup);
    
    /***** Prevent accidental refresh *****/
    window.addEventListener('beforeunload', function(e) {
      // This exact message might not be shown in modern browsers - they use their own standard messages
      // But the browser will still display a confirmation dialog
      const confirmationMessage = "Oi, you rancid, poopy-smelling vermin! Got too excited, did ya? Click \"OK,\" and poof—all your precious metadata's gone. No take-backs. Now scram before your stink lingers! 🪤";
      
      // Modern standard way to trigger the confirmation dialog
      e.preventDefault();
      e.returnValue = confirmationMessage;
      
      // For older browsers
      return confirmationMessage;
    });
    
    /***** Save & Load Functionality *****/
    function saveAllData() {
      // Create a data object with everything that needs to be saved
      const dataToSave = {
        version: "0.2",
        timestamp: new Date().toISOString(),
        layerNames: layerNames,
        plate96wData: plate96wData,
        plate384wData: plate384wData
      };
      
      // Convert to a JSON string
      const jsonString = JSON.stringify(dataToSave);
      
      // Create a downloadable blob
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      // Create a temporary link and trigger download
      const link = document.createElement('a');
      link.href = url;
      link.download = "ratmap_data.json";
      document.body.appendChild(link);
      link.click();
      
      // Clean up
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      // Show success message
      alert("Data successfully saved to ratmap_data.json");
    }
    
    function loadData(file) {
      // Create a file reader to read the uploaded file
      const reader = new FileReader();
      
      reader.onload = function(event) {
        try {
          // Parse the JSON string
          const data = JSON.parse(event.target.result);
          
          // Validate the data structure
          if (!validateImportData(data)) {
            alert("Invalid data format. Please ensure you're loading a valid RatMap data file.");
            return;
          }
          
          // Back up current state in case something goes wrong
          const backupLayerNames = [...layerNames];
          const backupPlate96wData = JSON.parse(JSON.stringify(plate96wData));
          const backupPlate384wData = JSON.parse(JSON.stringify(plate384wData));
          
          try {
            // Replace the application data
            layerNames = data.layerNames;
            plate96wData = data.plate96wData;
            plate384wData = data.plate384wData;
            
            // Update UI elements
            updateLayerDropdowns();
            
            // Check all plate checkboxes to make plates visible
            document.querySelectorAll('.plate96wCheckbox').forEach(cb => {
              if (!cb.checked) {
                cb.checked = true;
                cb.dispatchEvent(new Event('change', { bubbles: true }));
              }
            });
            
            document.querySelectorAll('.plate384wCheckbox').forEach(cb => {
              if (!cb.checked) {
                cb.checked = true;
                cb.dispatchEvent(new Event('change', { bubbles: true }));
              }
            });
            
            // Update the display
            updateAllDisplayedCells();
            updateRatCache();
            
            // Sort plates after loading data
            sortPlatesByID('plate96wContainer');
            sortPlatesByID('plate384wContainer');
            
            // Equalize plate dimensions after loading data
            setTimeout(equalizeTableDimensions, 200);
            
            // Show success message
            alert("Data successfully loaded!");
          } catch (e) {
            // Restore backup if something went wrong
            console.error("Error applying imported data:", e);
            layerNames = backupLayerNames;
            plate96wData = backupPlate96wData;
            plate384wData = backupPlate384wData;
            alert("Error applying imported data. Your previous data has been restored.");
          }
        } catch (error) {
          console.error("Error parsing JSON:", error);
          alert("Failed to parse the file. Please ensure it's a valid JSON file.");
        }
      };
      
      reader.onerror = function() {
        alert("Error reading the file. Please try again.");
      };
      
      // Read the file as text
      reader.readAsText(file);
    }
    
    function validateImportData(data) {
      // Check for required properties
      if (!data.layerNames || !data.plate96wData || !data.plate384wData) {
        console.error("Missing required properties in import data");
        return false;
      }
      
      // Validate layerNames
      if (!Array.isArray(data.layerNames) || data.layerNames.length !== 9) {
        console.error("layerNames must be an array of 9 items");
        return false;
      }
      
      // Validate plate data structure
      try {
        // Check the 96-well plate data structure
        for (const plateId in data.plate96wData) {
          const plate = data.plate96wData[plateId];
          // Check a few wells to validate structure
          const wells = rows96.map(r => r + cols96[0]); // Get a few well IDs
          for (const wellId of wells) {
            if (!plate[wellId]) continue; // Skip if well doesn't exist
            
            for (let i = 1; i <= 9; i++) {
              if (typeof plate[wellId][`metadata_${i}`] !== 'string') {
                throw new Error(`Invalid metadata in plate ${plateId} well ${wellId}`);
              }
            }
          }
        }
        
        // Check the 384-well plate data structure
        for (const plateId in data.plate384wData) {
          const plate = data.plate384wData[plateId];
          // Check a few wells to validate structure
          const wells = rows384.map(r => r + cols384[0]); // Get a few well IDs
          for (const wellId of wells) {
            if (!plate[wellId]) continue; // Skip if well doesn't exist
            
            for (let i = 1; i <= 9; i++) {
              if (typeof plate[wellId][`metadata_${i}`] !== 'string') {
                throw new Error(`Invalid metadata in plate ${plateId} well ${wellId}`);
              }
            }
            
            if (typeof plate[wellId].Src_Plate_96w !== 'string' ||
                typeof plate[wellId].Src_Well_96w !== 'string') {
              throw new Error(`Invalid mapping data in plate ${plateId} well ${wellId}`);
            }
          }
        }
      } catch (error) {
        console.error("Validation error:", error);
        return false;
      }
      
      return true;
    }
    
    // Event listeners for save and load buttons
    document.getElementById('saveDataButton').addEventListener('click', function() {
      saveAllData();
    });
    
    document.getElementById('loadDataButton').addEventListener('click', function() {
      document.getElementById('fileInput').click();
    });
    
    document.getElementById('fileInput').addEventListener('change', function(event) {
      if (event.target.files.length > 0) {
        loadData(event.target.files[0]);
        // Reset the file input so the same file can be loaded again
        event.target.value = '';
      }
    });

    /***** Ensure Uniform Plate Dimensions *****/
    function equalizeTableDimensions() {
      // Separate tables by type
      const tables96w = document.querySelectorAll('.plateTable[data-plate$="96w"]');
      const tables384w = document.querySelectorAll('.plateTable[data-plate$="384w"]');
      
      // Equalize 96-well plates if there are multiple
      if (tables96w.length > 1) {
        equalizeTableSet(tables96w);
      }
      
      // Equalize 384-well plates if there are multiple
      if (tables384w.length > 1) {
        equalizeTableSet(tables384w);
      }
    }
    
    function equalizeTableSet(tables) {
      // Get all rows and all columns
      const allRows = [];
      const allCols = [];
      const allCells = [];
      
      // Collect all rows, columns and cells
      tables.forEach(table => {
        // Get all rows (excluding header row)
        const rows = Array.from(table.querySelectorAll('tbody tr'));
        allRows.push(...rows);
        
        // Get all columns (excluding first column which is row header)
        const firstRow = table.querySelector('thead tr');
        if (firstRow) {
          const cols = Array.from(firstRow.querySelectorAll('th')).slice(1); // Skip first th (corner cell)
          allCols.push(...cols);
        }
        
        // Get all data cells
        const cells = Array.from(table.querySelectorAll('td'));
        allCells.push(...cells);
      });
      
      // Find maximum row height
      let maxRowHeight = 0;
      allRows.forEach(row => {
        const height = row.getBoundingClientRect().height;
        if (height > maxRowHeight) {
          maxRowHeight = height;
        }
      });
      
      // Find maximum column width
      let maxColWidth = 0;
      allCols.forEach(col => {
        const width = col.getBoundingClientRect().width;
        if (width > maxColWidth) {
          maxColWidth = width;
        }
      });
      
      // Find maximum cell height and width
      let maxCellHeight = 0;
      let maxCellWidth = 0;
      allCells.forEach(cell => {
        const rect = cell.getBoundingClientRect();
        if (rect.height > maxCellHeight) {
          maxCellHeight = rect.height;
        }
        if (rect.width > maxCellWidth) {
          maxCellWidth = rect.width;
        }
      });
      
      // Apply maximum dimensions to all tables
      tables.forEach(table => {
        // Set fixed widths on header cells (except first one)
        const headerCells = Array.from(table.querySelectorAll('thead th')).slice(1);
        headerCells.forEach(cell => {
          cell.style.width = `${maxColWidth}px`;
          cell.style.minWidth = `${maxColWidth}px`;
        });
        
        // Set fixed heights on all rows
        const rows = Array.from(table.querySelectorAll('tbody tr'));
        rows.forEach(row => {
          row.style.height = `${maxRowHeight}px`;
        });
        
        // Set fixed dimensions on all data cells
        const cells = Array.from(table.querySelectorAll('td'));
        cells.forEach(cell => {
          cell.style.width = `${maxCellWidth}px`;
          cell.style.height = `${maxCellHeight}px`;
          cell.style.minWidth = `${maxCellWidth}px`;
          cell.style.minHeight = `${maxCellHeight}px`;
        });
        
        // Ensure the table has a consistent total width
        table.style.width = '100%';
        table.style.tableLayout = 'fixed';
      });
    }

    // Add initial call to equalize dimensions on window load
    window.addEventListener('load', function() {
      setTimeout(equalizeTableDimensions, 500);
    });
    
    // Add equalizeTableDimensions call when window is resized
    window.addEventListener('resize', function() {
      clearTimeout(window.resizeTimer);
      window.resizeTimer = setTimeout(equalizeTableDimensions, 250);
    });
  </script>
</body>
</html>